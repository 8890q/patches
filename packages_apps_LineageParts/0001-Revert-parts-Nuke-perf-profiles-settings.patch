From c6c27c369010ca2d0c33ea6165ed53d9bdd4f0dc Mon Sep 17 00:00:00 2001
From: ivanmeler <i_ivan@windowslive.com>
Date: Wed, 9 Mar 2022 19:00:15 +0000
Subject: [PATCH] Revert "parts: Nuke perf profiles settings"

This reverts commit 015c93feeebbb17e23bd815f3cd8581f1ff74188.
---
 res/drawable/ic_perf_profile_avd.xml          |   9 +
 res/values/arrays.xml                         |  19 +-
 res/values/colors.xml                         |   7 +-
 res/values/strings.xml                        |  15 +
 res/xml/parts_catalog.xml                     |   8 +-
 res/xml/perf_profile_settings.xml             |  54 +++
 .../power/PerfProfileSettings.java            | 315 ++++++++++++++++++
 .../widget/SeekBarPreference.java             | 280 ++++++++++++++++
 8 files changed, 703 insertions(+), 4 deletions(-)
 create mode 100644 res/drawable/ic_perf_profile_avd.xml
 create mode 100644 res/xml/perf_profile_settings.xml
 create mode 100644 src/org/lineageos/lineageparts/power/PerfProfileSettings.java
 create mode 100644 src/org/lineageos/lineageparts/widget/SeekBarPreference.java

diff --git a/res/drawable/ic_perf_profile_avd.xml b/res/drawable/ic_perf_profile_avd.xml
new file mode 100644
index 0000000..7560afc
--- /dev/null
+++ b/res/drawable/ic_perf_profile_avd.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:drawable="@drawable/ic_perf_profile">
+    
+    <target
+        android:name="needle"
+        android:animation="@anim/ic_perf_profile_needle"/>
+
+</animated-vector>
diff --git a/res/values/arrays.xml b/res/values/arrays.xml
index ef8ac34..051b70a 100644
--- a/res/values/arrays.xml
+++ b/res/values/arrays.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
      Copyright (C) 2012-2015 The CyanogenMod Project
-                   2017-2022 The LineageOS Project
+     Copyright (C) 2017-2018 The LineageOS Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -333,6 +333,23 @@
         <item>0</item>
     </string-array>
 
+    <!-- Auto power save mode: Allowable trigger threshold entries -->
+    <string-array name="auto_power_save_entries" translatable="false">
+        <item>@string/auto_power_save_never</item>
+        <item>5%</item>
+        <item>15%</item>
+        <item>25%</item>
+    </string-array>
+
+    <!-- Auto power save mode: Allowable trigger threshold levels.
+         Similar to the battery_saver_trigger_values integer-array in Settings -->
+    <string-array name="auto_power_save_values" translatable="false">
+        <item>0</item>
+        <item>5</item>
+        <item>15</item>
+        <item>25</item>
+    </string-array>
+
     <!-- Gestures - touchscreen gesture actions -->
     <string-array name="touchscreen_gesture_action_entries">
         <item>@string/touchscreen_gesture_action_do_nothing</item>
diff --git a/res/values/colors.xml b/res/values/colors.xml
index 28335c3..72a5d3f 100644
--- a/res/values/colors.xml
+++ b/res/values/colors.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
 	Copyright (C) 2016 The CyanogenMod Project
-	              2019-2022 The LineageOS Project
+	              2019-2021 The LineageOS Project
 
 	Licensed under the Apache License, Version 2.0 (the "License");
 	you may not use this file except in compliance with the License.
@@ -19,7 +19,10 @@
     <!-- Contributors -->
     <color name="contributors_cloud_selected_color">#ff5252</color>
 
-    <!-- Trust -->
+
+    <color name="perf_hot">#ffd10015</color>
+    <color name="perf_cold">#ff005994</color>
+
     <color name="trust_status_good">#36B37E</color>
     <color name="trust_status_poor">#FFAB00</color>
     <color name="trust_status_bad">#FF5630</color>
diff --git a/res/values/strings.xml b/res/values/strings.xml
index 9fe4181..adb5ada 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -566,6 +566,21 @@
     <string name="display_rotation_180_title">180 degrees</string>
     <string name="display_rotation_270_title">270 degrees</string>
 
+    <!-- Power: Performance profiles -->
+    <string name="perf_profile_settings_title">Battery saver and performance</string>
+    <string name="perf_profile_settings_summary">Adjust power saving features and device performance</string>
+    <string name="perf_profile_overview_summary">Current profile: <xliff:g id="perf_profile_name">%1$s</xliff:g></string>
+    <string name="perf_profile_category_title">Device performance</string>
+    <string name="perf_profile_title">Performance profile: <xliff:g id="perf_profile_name">%1$s</xliff:g></string>
+    <string name="perf_profile_fail_toast">The performance profile is currently unavailable</string>
+    <string name="power_save_category_title">Battery saving</string>
+    <string name="power_save_title">Extreme power saver</string>
+    <string name="power_save_summary">Restrict device performance and background activity to save power</string>
+    <string name="auto_power_save_title">Automatic power saver</string>
+    <string name="auto_power_save_summary_on">Automatically enable power save mode at %s battery</string>
+    <string name="auto_power_save_summary_off">Do not enable power save mode automatically</string>
+    <string name="auto_power_save_never">Never</string>
+
     <!-- Applications: Long screen -->
     <string name="long_screen_settings_title">Full screen apps</string>
     <string name="long_screen_settings_summary">Force legacy apps to use full screen aspect ratio</string>
diff --git a/res/xml/parts_catalog.xml b/res/xml/parts_catalog.xml
index 803b214..2d8dca7 100644
--- a/res/xml/parts_catalog.xml
+++ b/res/xml/parts_catalog.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
      Copyright (C) 2016 The CyanogenMod Project
-                   2017-2022 The LineageOS Project
+                   2017-2019 The LineageOS Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -80,6 +80,12 @@
           android:fragment="org.lineageos.lineageparts.input.PowerMenuActions"
           lineage:xmlRes="@xml/power_menu_settings" />
 
+    <part android:key="perf_profile_settings"
+          android:title="@string/perf_profile_settings_title"
+          android:summary="@string/perf_profile_settings_summary"
+          android:fragment="org.lineageos.lineageparts.power.PerfProfileSettings"
+          lineage:xmlRes="@xml/perf_profile_settings" />
+
     <part android:key="long_screen_settings"
           android:title="@string/long_screen_settings_title"
           android:summary="@string/long_screen_settings_summary"
diff --git a/res/xml/perf_profile_settings.xml b/res/xml/perf_profile_settings.xml
new file mode 100644
index 0000000..0b301a9
--- /dev/null
+++ b/res/xml/perf_profile_settings.xml
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<PreferenceScreen
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:settings="http://schemas.android.com/apk/res-auto"
+    android:key="perf_profile_settings"
+    android:title="@string/perf_profile_settings_title" >
+
+    <PreferenceCategory
+        android:key="power_save_category"
+        android:title="@string/power_save_category_title">
+
+        <SwitchPreference
+            android:key="power_save"
+            android:title="@string/power_save_title"
+            android:summary="@string/power_save_summary"
+            android:persistent="false" />
+
+        <ListPreference
+            android:key="auto_power_save"
+            android:title="@string/auto_power_save_title"
+            android:persistent="false" />
+
+    </PreferenceCategory>
+
+    <PreferenceCategory
+        android:key="perf_profile_category"
+        android:title="@string/perf_profile_category_title">
+
+        <org.lineageos.lineageparts.widget.SeekBarPreference
+            android:key="perf_seekbar"
+            android:title="@string/perf_profile_title"
+            android:max="4"
+            android:defaultValue="1"
+            android:persistent="false"
+            android:layout="@layout/preference_slider"
+            settings:allowDividerAbove="false" />
+
+    </PreferenceCategory>
+</PreferenceScreen>
diff --git a/src/org/lineageos/lineageparts/power/PerfProfileSettings.java b/src/org/lineageos/lineageparts/power/PerfProfileSettings.java
new file mode 100644
index 0000000..a3874c8
--- /dev/null
+++ b/src/org/lineageos/lineageparts/power/PerfProfileSettings.java
@@ -0,0 +1,315 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ *               2017-2020 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.lineageparts.power;
+
+import android.animation.AnimatorSet;
+import android.animation.ValueAnimator;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.graphics.PorterDuff;
+import android.graphics.drawable.AnimatedVectorDrawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.PowerManager;
+import android.provider.Settings.Global;
+import android.util.ArraySet;
+import android.util.TypedValue;
+import android.view.animation.AccelerateDecelerateInterpolator;
+import android.widget.Toast;
+
+import androidx.preference.ListPreference;
+import androidx.preference.Preference;
+import androidx.preference.SwitchPreference;
+
+import org.lineageos.lineageparts.PartsUpdater;
+import org.lineageos.lineageparts.R;
+import org.lineageos.lineageparts.SettingsPreferenceFragment;
+import org.lineageos.lineageparts.search.BaseSearchIndexProvider;
+import org.lineageos.lineageparts.search.Searchable;
+import org.lineageos.lineageparts.widget.SeekBarPreference;
+import org.lineageos.internal.graphics.drawable.StopMotionVectorDrawable;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import lineageos.power.PerformanceManager;
+import lineageos.power.PerformanceProfile;
+
+import lineageos.providers.LineageSettings;
+
+
+import static lineageos.power.PerformanceManager.PROFILE_POWER_SAVE;
+
+public class PerfProfileSettings extends SettingsPreferenceFragment
+        implements Preference.OnPreferenceChangeListener, Searchable {
+
+    private static final String KEY_PERF_PROFILE_CATEGORY = "perf_profile_category";
+    private static final String KEY_AUTO_POWER_SAVE  = "auto_power_save";
+    private static final String KEY_POWER_SAVE       = "power_save";
+    private static final String KEY_PERF_SEEKBAR     = "perf_seekbar";
+
+    private ListPreference mAutoPowerSavePref;
+    private SwitchPreference   mPowerSavePref;
+
+    private SeekBarPreference        mPerfSeekBar;
+    private StopMotionVectorDrawable mPerfDrawable;
+    private PerfIconAnimator         mAnimator;
+
+    private PowerManager       mPowerManager;
+    private PerformanceManager mPerf;
+
+    private int mLastSliderValue = 0;
+
+    private List<PerformanceProfile> mProfiles;
+
+    private final BroadcastReceiver mPowerSaveReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            updatePowerSaveValue();
+        }
+    };
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        addPreferencesFromResource(R.xml.perf_profile_settings);
+
+        mPerfSeekBar = findPreference(KEY_PERF_SEEKBAR);
+        mAutoPowerSavePref = findPreference(KEY_AUTO_POWER_SAVE);
+        mPowerSavePref = findPreference(KEY_POWER_SAVE);
+
+        mPowerManager = getActivity().getSystemService(PowerManager.class);
+        mPerf = PerformanceManager.getInstance(getActivity());
+
+        mProfiles = new ArrayList<>(mPerf.getPowerProfiles());
+
+        int count = mProfiles.size();
+
+        if (count == 0) {
+            removePreference(KEY_PERF_PROFILE_CATEGORY);
+            mPerfSeekBar = null;
+        } else {
+            mPerfDrawable = new StopMotionVectorDrawable(
+                    (AnimatedVectorDrawable) getActivity().getDrawable(
+                            R.drawable.ic_perf_profile_avd));
+            mPerfSeekBar.setIconDrawable(mPerfDrawable);
+            mAnimator = new PerfIconAnimator(getActivity(), mPerfDrawable);
+
+            mPerfSeekBar.setMax(count - 1);
+            mPerfSeekBar.setOnPreferenceChangeListener(this);
+            updatePerfSettings();
+
+            watch(LineageSettings.Secure.getUriFor(LineageSettings.Secure.PERFORMANCE_PROFILE));
+        }
+
+        mAutoPowerSavePref.setEntries(R.array.auto_power_save_entries);
+        mAutoPowerSavePref.setEntryValues(R.array.auto_power_save_values);
+        updateAutoPowerSaveValue();
+        mAutoPowerSavePref.setOnPreferenceChangeListener(this);
+        mPowerSavePref.setOnPreferenceChangeListener(this);
+    }
+
+
+    private static class PerfIconAnimator {
+
+        private final Context mContext;
+        private final StopMotionVectorDrawable mDrawable;
+
+        private final ValueAnimator mGradient;
+        private final AnimatorSet   mAnimator = new AnimatorSet();
+
+        public PerfIconAnimator(Context context, StopMotionVectorDrawable drawable) {
+            mContext = context;
+            mDrawable = drawable;
+            TypedValue colorAccent = new TypedValue();
+            mContext.getTheme().resolveAttribute(com.android.internal.R.attr.colorAccent,
+                    colorAccent, true);
+            mGradient = ValueAnimator.ofArgb(
+                    mContext.getResources().getColor(R.color.perf_cold),
+                    mContext.getResources().getColor(colorAccent.resourceId),
+                    mContext.getResources().getColor(R.color.perf_hot));
+            mAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
+        }
+
+        private int getColorAt(float fraction) {
+            mGradient.setCurrentFraction(fraction);
+            return (Integer) mGradient.getAnimatedValue();
+        }
+
+        public void animateRange(float from, float to) {
+            mAnimator.cancel();
+            mAnimator.removeAllListeners();
+
+            final ValueAnimator scale = ValueAnimator.ofFloat(from, to);
+            final ValueAnimator color = ValueAnimator.ofArgb(
+                    getColorAt(from), getColorAt(from + ((to - from) / 2)), getColorAt(to));
+
+            scale.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+                @Override
+                public void onAnimationUpdate(ValueAnimator valueAnimator) {
+                    mDrawable.setCurrentFraction(
+                            (Float) valueAnimator.getAnimatedValue());
+                }
+            });
+            color.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+                @Override
+                public void onAnimationUpdate(ValueAnimator valueAnimator) {
+                    mDrawable.setColorFilter(
+                            (Integer) valueAnimator.getAnimatedValue(),
+                            PorterDuff.Mode.SRC_IN);
+                }
+            });
+
+            mAnimator.play(scale).with(color);
+            mAnimator.start();
+        }
+    }
+
+    private void updatePerfSettings() {
+        if (mPerfSeekBar == null) {
+            return;
+        }
+
+        PerformanceProfile profile = mPowerManager.isPowerSaveMode() ?
+                mPerf.getPowerProfile(PROFILE_POWER_SAVE) : mPerf.getActivePowerProfile();
+        mPerfSeekBar.setProgress(mProfiles.indexOf(profile));
+        mPerfSeekBar.setTitle(getResources().getString(
+                R.string.perf_profile_title, profile.getName()));
+        mPerfSeekBar.setSummary(profile.getDescription());
+
+        if (mPerfDrawable != null) {
+            final float start = mProfiles.get(mLastSliderValue).getWeight();
+            final float end = profile.getWeight();
+            mAnimator.animateRange(start, end);
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        if (mPowerSavePref != null) {
+            updatePowerSaveValue();
+            getActivity().registerReceiver(mPowerSaveReceiver,
+                    new IntentFilter(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED));
+        }
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        if (mPowerSavePref != null) {
+            getActivity().unregisterReceiver(mPowerSaveReceiver);
+        }
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (preference == mPerfSeekBar) {
+            mLastSliderValue = mPerfSeekBar.getProgress();
+            int index = (Integer) newValue;
+            if (!mPerf.setPowerProfile(mProfiles.get(index).getId())) {
+                // Don't just fail silently, inform the user as well
+                Toast.makeText(getActivity(),
+                        R.string.perf_profile_fail_toast, Toast.LENGTH_SHORT).show();
+                return false;
+            }
+        } else if (preference == mPowerSavePref) {
+            if (!mPowerManager.setPowerSaveModeEnabled((boolean) newValue)) {
+                // Don't just fail silently, inform the user as well
+                Toast.makeText(getActivity(),
+                        R.string.perf_profile_fail_toast, Toast.LENGTH_SHORT).show();
+                return false;
+            }
+            updatePowerSaveValue();
+        } else if (preference == mAutoPowerSavePref) {
+            final int level = Integer.parseInt((String) newValue);
+            Global.putInt(getContentResolver(), Global.LOW_POWER_MODE_TRIGGER_LEVEL, level);
+            updateAutoPowerSaveSummary(level);
+        }
+        return true;
+    }
+
+    @Override
+    public void onSettingsChanged(Uri contentUri) {
+        super.onSettingsChanged(contentUri);
+        updatePerfSettings();
+    }
+
+    private void updatePowerSaveValue() {
+        mPowerSavePref.setChecked(mPowerManager.isPowerSaveMode());
+        updatePerfSettings();
+        // The profile was changed automatically without updating the preference
+        PartsUpdater.notifyChanged(getActivity(), getPreferenceScreen().getKey());
+    }
+
+    private void updateAutoPowerSaveValue() {
+        final int level = Global.getInt(
+                getContentResolver(), Global.LOW_POWER_MODE_TRIGGER_LEVEL, 0);
+        mAutoPowerSavePref.setValue(String.valueOf(level));
+        updateAutoPowerSaveSummary(level);
+    }
+
+    private void updateAutoPowerSaveSummary(int level) {
+        mAutoPowerSavePref.setSummary(level == 0
+                ? R.string.auto_power_save_summary_off
+                : R.string.auto_power_save_summary_on);
+    }
+
+    public static final SummaryProvider SUMMARY_PROVIDER = new SummaryProvider() {
+        @Override
+        public String getSummary(Context context, String key) {
+            final PowerManager powerManager = context.getSystemService(PowerManager.class);
+            final PerformanceManager perfManager = PerformanceManager.getInstance(context);
+            final PerformanceProfile profile = powerManager.isPowerSaveMode() ?
+                    perfManager.getPowerProfile(PROFILE_POWER_SAVE) :
+                    perfManager.getActivePowerProfile();
+            String summary = context.getString(R.string.perf_profile_settings_summary);
+            if (profile != null) {
+                summary += "\n\n" + context.getResources().getString(
+                        R.string.perf_profile_overview_summary,
+                        profile.getName());
+            }
+            return summary.replace("\\n", System.getProperty("line.separator"));
+        }
+    };
+
+    public static final Searchable.SearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =
+            new BaseSearchIndexProvider() {
+
+        @Override
+        public Set<String> getNonIndexableKeys(Context context) {
+            final Set<String> result = new ArraySet<String>();
+
+            final PerformanceManager perfManager = PerformanceManager.getInstance(context);
+            final List<PerformanceProfile> profiles =
+                    new ArrayList<>(perfManager.getPowerProfiles());
+
+            if (profiles.size() == 0) {
+                result.add(KEY_PERF_PROFILE_CATEGORY);
+                result.add(KEY_PERF_SEEKBAR);
+            }
+            return result;
+        }
+    };
+}
diff --git a/src/org/lineageos/lineageparts/widget/SeekBarPreference.java b/src/org/lineageos/lineageparts/widget/SeekBarPreference.java
new file mode 100644
index 0000000..2300ebb
--- /dev/null
+++ b/src/org/lineageos/lineageparts/widget/SeekBarPreference.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *               2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.lineageparts.widget;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.drawable.Drawable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.view.KeyEvent;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.SeekBar;
+import android.widget.SeekBar.OnSeekBarChangeListener;
+
+import androidx.preference.PreferenceViewHolder;
+
+import com.android.settingslib.RestrictedPreference;
+
+import org.lineageos.lineageparts.R;
+
+/**
+ * Based on android.preference.SeekBarPreference, but uses support preference as base.
+ */
+public class SeekBarPreference extends RestrictedPreference
+        implements OnSeekBarChangeListener, View.OnKeyListener {
+
+    private int mProgress;
+    private int mMax;
+    private boolean mTrackingTouch;
+
+    private ImageView mIconView;
+    private Drawable mIcon;
+
+    public SeekBarPreference(
+            Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
+        super(context, attrs, defStyleAttr, defStyleRes);
+
+        TypedArray a = context.obtainStyledAttributes(
+                attrs, com.android.internal.R.styleable.ProgressBar, defStyleAttr, defStyleRes);
+        setMax(a.getInt(com.android.internal.R.styleable.ProgressBar_max, mMax));
+        a.recycle();
+
+        a = context.obtainStyledAttributes(attrs,
+                com.android.internal.R.styleable.SeekBarPreference, defStyleAttr, defStyleRes);
+        final int layoutResId = a.getResourceId(
+                com.android.internal.R.styleable.SeekBarPreference_layout,
+                com.android.internal.R.layout.preference_widget_seekbar);
+        a.recycle();
+
+        setLayoutResource(layoutResId);
+    }
+
+    public SeekBarPreference(Context context, AttributeSet attrs, int defStyleAttr) {
+        this(context, attrs, defStyleAttr, 0);
+    }
+
+    public SeekBarPreference(Context context, AttributeSet attrs) {
+        this(context, attrs, com.android.internal.R.attr.seekBarPreferenceStyle);
+    }
+
+    public SeekBarPreference(Context context) {
+        this(context, null);
+    }
+
+    @Override
+    public void onBindViewHolder(PreferenceViewHolder view) {
+        super.onBindViewHolder(view);
+
+        mIconView = (ImageView) view.findViewById(R.id.icon);
+        if (mIcon != null) {
+            mIconView.setImageDrawable(mIcon);
+        }
+
+        view.itemView.setOnKeyListener(this);
+        SeekBar seekBar = (SeekBar) view.findViewById(R.id.seekbar);
+        seekBar.setOnSeekBarChangeListener(this);
+        seekBar.setMax(mMax);
+        seekBar.setProgress(mProgress);
+        seekBar.setEnabled(isEnabled());
+    }
+
+    public ImageView getIconView() {
+        return mIconView;
+    }
+
+    public void setIconDrawable(Drawable drawable) {
+        if (mIconView != null) {
+            mIconView.setImageDrawable(drawable);
+        }
+        mIcon = drawable;
+    }
+    @Override
+    protected void onSetInitialValue(boolean restoreValue, Object defaultValue) {
+        setProgress(restoreValue ? getPersistedInt(mProgress)
+                : (Integer) defaultValue);
+    }
+
+    @Override
+    protected Object onGetDefaultValue(TypedArray a, int index) {
+        return a.getInt(index, 0);
+    }
+
+    @Override
+    public boolean onKey(View v, int keyCode, KeyEvent event) {
+        if (event.getAction() != KeyEvent.ACTION_DOWN) {
+            return false;
+        }
+
+        SeekBar seekBar = (SeekBar) v.findViewById(R.id.seekbar);
+        if (seekBar == null) {
+            return false;
+        }
+        return seekBar.onKeyDown(keyCode, event);
+    }
+
+    public void setMax(int max) {
+        if (max != mMax) {
+            mMax = max;
+            notifyChanged();
+        }
+    }
+
+    public void setProgress(int progress) {
+        setProgress(progress, true);
+    }
+
+    private void setProgress(int progress, boolean notifyChanged) {
+        if (progress > mMax) {
+            progress = mMax;
+        }
+        if (progress < 0) {
+            progress = 0;
+        }
+        if (progress != mProgress) {
+            mProgress = progress;
+            persistInt(progress);
+            if (notifyChanged) {
+                notifyChanged();
+            }
+        }
+    }
+
+    public int getProgress() {
+        return mProgress;
+    }
+
+    /**
+     * Persist the seekBar's progress value if callChangeListener
+     * returns true, otherwise set the seekBar's progress to the stored value
+     */
+    void syncProgress(SeekBar seekBar) {
+        int progress = seekBar.getProgress();
+        if (progress != mProgress) {
+            if (callChangeListener(progress)) {
+                setProgress(progress, false);
+            } else {
+                seekBar.setProgress(mProgress);
+            }
+        }
+    }
+
+    @Override
+    public void onProgressChanged(
+            SeekBar seekBar, int progress, boolean fromUser) {
+        if (fromUser && !mTrackingTouch) {
+            syncProgress(seekBar);
+        }
+    }
+
+    @Override
+    public void onStartTrackingTouch(SeekBar seekBar) {
+        mTrackingTouch = true;
+    }
+
+    @Override
+    public void onStopTrackingTouch(SeekBar seekBar) {
+        mTrackingTouch = false;
+        if (seekBar.getProgress() != mProgress) {
+            syncProgress(seekBar);
+        }
+    }
+
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        /*
+         * Suppose a client uses this preference type without persisting. We
+         * must save the instance state so it is able to, for example, survive
+         * orientation changes.
+         */
+
+        final Parcelable superState = super.onSaveInstanceState();
+        if (isPersistent()) {
+            // No need to save instance state since it's persistent
+            return superState;
+        }
+
+        // Save the instance state
+        final SavedState myState = new SavedState(superState);
+        myState.progress = mProgress;
+        myState.max = mMax;
+        return myState;
+    }
+
+    @Override
+    protected void onRestoreInstanceState(Parcelable state) {
+        if (!state.getClass().equals(SavedState.class)) {
+            // Didn't save state for us in onSaveInstanceState
+            super.onRestoreInstanceState(state);
+            return;
+        }
+
+        // Restore the instance state
+        SavedState myState = (SavedState) state;
+        super.onRestoreInstanceState(myState.getSuperState());
+        mProgress = myState.progress;
+        mMax = myState.max;
+        notifyChanged();
+    }
+
+    /**
+     * SavedState, a subclass of {@link BaseSavedState}, will store the state
+     * of MyPreference, a subclass of Preference.
+     * <p>
+     * It is important to always call through to super methods.
+     */
+    private static class SavedState extends BaseSavedState {
+        int progress;
+        int max;
+
+        public SavedState(Parcel source) {
+            super(source);
+
+            // Restore the click counter
+            progress = source.readInt();
+            max = source.readInt();
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            super.writeToParcel(dest, flags);
+
+            // Save the click counter
+            dest.writeInt(progress);
+            dest.writeInt(max);
+        }
+
+        public SavedState(Parcelable superState) {
+            super(superState);
+        }
+
+        @SuppressWarnings("unused")
+        public static final Parcelable.Creator<SavedState> CREATOR =
+                new Parcelable.Creator<SavedState>() {
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+    }
+}
-- 
2.25.1

