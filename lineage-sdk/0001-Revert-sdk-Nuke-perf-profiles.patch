From 2e61ea5b7fdeac3a42765445d5c66673add6ffde Mon Sep 17 00:00:00 2001
From: ivanmeler <i_ivan@windowslive.com>
Date: Wed, 9 Mar 2022 18:56:23 +0000
Subject: [PATCH] Revert "sdk: Nuke perf profiles"

This reverts commit 9265e4085d4627f6a5657a3f5406a7fbb1f131a9.

Change-Id: I865f762cb131901fe05cf3645cc13d18462dbc5a
---
 Android.mk                                    |   2 +-
 api/lineage_current.txt                       |  34 ++
 host/migration/src/LineageSettings.java       |  16 +-
 .../internal/PerformanceManagerService.java   | 511 ++++++++++++++++++
 lineage/res/AndroidManifest.xml               |   7 +
 lineage/res/res/values/arrays.xml             |  41 +-
 lineage/res/res/values/config.xml             |   7 +-
 lineage/res/res/values/strings.xml            |  21 +-
 lineage/res/res/values/symbols.xml            |  20 +-
 .../lineageos/power/IPerformanceManager.aidl  |  35 ++
 .../lineageos/power/PerformanceManager.java   | 267 +++++++++
 .../lineageos/power/PerformanceProfile.aidl   |  19 +
 .../lineageos/power/PerformanceProfile.java   | 159 ++++++
 .../lineageos/providers/LineageSettings.java  |  14 +
 .../power/unit/PerfomanceManagerTest.java     | 111 ++++
 .../apiv4/ApiV4PriorReleaseInterfaces.java    |  11 +
 16 files changed, 1269 insertions(+), 6 deletions(-)
 create mode 100644 lineage/lib/main/java/org/lineageos/platform/internal/PerformanceManagerService.java
 create mode 100644 sdk/src/java/lineageos/power/IPerformanceManager.aidl
 create mode 100644 sdk/src/java/lineageos/power/PerformanceManager.java
 create mode 100644 sdk/src/java/lineageos/power/PerformanceProfile.aidl
 create mode 100644 sdk/src/java/lineageos/power/PerformanceProfile.java
 create mode 100644 tests/src/org/lineageos/tests/power/unit/PerfomanceManagerTest.java

diff --git a/Android.mk b/Android.mk
index d4247595..104ff8d8 100644
--- a/Android.mk
+++ b/Android.mk
@@ -29,7 +29,7 @@ include $(CLEAR_VARS)
 lineage_platform_res := APPS/org.lineageos.platform-res_intermediates/aapt
 
 # List of packages used in lineage-api-stubs
-lineage_stub_packages := lineageos.app:lineageos.content:lineageos.hardware:lineageos.media:lineageos.os:lineageos.preference:lineageos.profiles:lineageos.providers:lineageos.platform:lineageos.util:lineageos.trust
+lineage_stub_packages := lineageos.app:lineageos.content:lineageos.hardware:lineageos.media:lineageos.os:lineageos.preference:lineageos.profiles:lineageos.providers:lineageos.power:lineageos.platform:lineageos.util:lineageos.trust
 
 lineage_framework_module := $(LOCAL_INSTALLED_MODULE)
 
diff --git a/api/lineage_current.txt b/api/lineage_current.txt
index 4601d245..440698d2 100644
--- a/api/lineage_current.txt
+++ b/api/lineage_current.txt
@@ -401,6 +401,40 @@ package lineageos.platform {
 
 }
 
+package lineageos.power {
+
+  public class PerformanceManager {
+    method public lineageos.power.PerformanceProfile getActivePowerProfile();
+    method public static lineageos.power.PerformanceManager getInstance(android.content.Context);
+    method public int getNumberOfProfiles();
+    method public int getPowerProfile();
+    method public lineageos.power.PerformanceProfile getPowerProfile(int);
+    method public java.util.SortedSet<lineageos.power.PerformanceProfile> getPowerProfiles();
+    method public boolean setPowerProfile(int);
+    method public boolean setPowerProfile(lineageos.power.PerformanceProfile);
+    field public static final java.lang.String POWER_PROFILE_CHANGED = "lineageos.power.PROFILE_CHANGED";
+    field public static final int PROFILE_BALANCED = 1; // 0x1
+    field public static final int PROFILE_BIAS_PERFORMANCE = 4; // 0x4
+    field public static final int PROFILE_BIAS_POWER_SAVE = 3; // 0x3
+    field public static final int PROFILE_HIGH_PERFORMANCE = 2; // 0x2
+    field public static final int PROFILE_POWER_SAVE = 0; // 0x0
+    field public static final java.lang.String TAG = "PerformanceManager";
+  }
+
+  public class PerformanceProfile implements java.lang.Comparable android.os.Parcelable {
+    ctor public PerformanceProfile(int, float, java.lang.String, java.lang.String);
+    method public int compareTo(lineageos.power.PerformanceProfile);
+    method public int describeContents();
+    method public java.lang.String getDescription();
+    method public int getId();
+    method public java.lang.String getName();
+    method public float getWeight();
+    method public void writeToParcel(android.os.Parcel, int);
+    field public static final android.os.Parcelable.Creator<lineageos.power.PerformanceProfile> CREATOR;
+  }
+
+}
+
 package lineageos.preference {
 
   public class GlobalSettingSwitchPreference extends lineageos.preference.SelfRemovingSwitchPreference {
diff --git a/host/migration/src/LineageSettings.java b/host/migration/src/LineageSettings.java
index 861a0ab2..2a161911 100644
--- a/host/migration/src/LineageSettings.java
+++ b/host/migration/src/LineageSettings.java
@@ -759,6 +759,18 @@ public final class LineageSettings {
         public static final int RING_HOME_BUTTON_BEHAVIOR_DEFAULT =
                 RING_HOME_BUTTON_BEHAVIOR_DO_NOTHING;
 
+        /**
+         * Performance profile
+         * @hide
+         */
+        public static final String PERFORMANCE_PROFILE = "performance_profile";
+
+        /**
+         * App-based performance profile selection
+         * @hide
+         */
+        public static final String APP_PERFORMANCE_PROFILES_ENABLED = "app_perf_profiles_enabled";
+
         /**
          * Launch actions for left/right lockscreen targets
          * @hide
@@ -839,7 +851,9 @@ public final class LineageSettings {
                 LineageSettings.Secure.ADVANCED_REBOOT,
                 LineageSettings.Secure.LOCKSCREEN_TARGETS,
                 LineageSettings.Secure.RING_HOME_BUTTON_BEHAVIOR,
-                LineageSettings.Secure.DEVELOPMENT_SHORTCUT};
+                LineageSettings.Secure.DEVELOPMENT_SHORTCUT,
+                LineageSettings.Secure.PERFORMANCE_PROFILE,
+                LineageSettings.Secure.APP_PERFORMANCE_PROFILES_ENABLED};
 
         /**
          * @hide
diff --git a/lineage/lib/main/java/org/lineageos/platform/internal/PerformanceManagerService.java b/lineage/lib/main/java/org/lineageos/platform/internal/PerformanceManagerService.java
new file mode 100644
index 00000000..aad3812e
--- /dev/null
+++ b/lineage/lib/main/java/org/lineageos/platform/internal/PerformanceManagerService.java
@@ -0,0 +1,511 @@
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ *               2018-2021 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.platform.internal;
+
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.PowerManager.ServiceType;
+import android.os.PowerManagerInternal;
+import android.os.PowerSaveState;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.util.ArrayMap;
+import android.util.Slog;
+
+import com.android.server.ServiceThread;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayDeque;
+import java.util.Date;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Objects;
+
+import lineageos.app.LineageContextConstants;
+import lineageos.power.IPerformanceManager;
+import lineageos.power.PerformanceProfile;
+
+import static lineageos.power.PerformanceManager.PROFILE_BALANCED;
+import static lineageos.power.PerformanceManager.PROFILE_POWER_SAVE;
+import static lineageos.providers.LineageSettings.Secure.PERFORMANCE_PROFILE;
+import static lineageos.providers.LineageSettings.Secure.getInt;
+import static lineageos.providers.LineageSettings.Secure.getUriFor;
+import static lineageos.providers.LineageSettings.Secure.putInt;
+
+/**
+ * @hide
+ */
+public class PerformanceManagerService extends LineageSystemService {
+
+    private static final String TAG = "PerformanceManager";
+
+    private static final boolean DEBUG = false;
+
+    private final Context mContext;
+
+    private final ArrayMap<Integer, PerformanceProfile> mProfiles = new ArrayMap<>();
+
+    private int mNumProfiles = 0;
+
+    private final ServiceThread mHandlerThread;
+    private final HintHandler mHandler;
+    private final Thread mWaitMpctlThread;
+
+    // keep in sync with hardware/libhardware/include/hardware/power.h
+    private final int POWER_HINT_SET_PROFILE  = 0x00000111;
+
+    private final int POWER_FEATURE_SUPPORTED_PROFILES = 0x00001000;
+
+    private PowerManagerInternal mPm;
+
+    // Observes user-controlled settings
+    private PerformanceSettingsObserver mObserver;
+
+    // Take lock when accessing mProfiles
+    private final Object mLock = new Object();
+
+    // Manipulate state variables under lock
+    private boolean mLowPowerModeEnabled = false;
+    private boolean mMpctlReady          = true;
+    private boolean mSystemReady         = false;
+    private int     mUserProfile         = -1;
+    private int     mActiveProfile       = -1;
+
+    // Dumpable circular buffer for boost logging
+    private final PerformanceLog mPerformanceLog = new PerformanceLog();
+
+    // Events on the handler
+    private static final int MSG_SET_PROFILE  = 1;
+
+    // PowerManager ServiceType to use when we're only
+    // interested in gleaning global battery saver state.
+    private static final int SERVICE_TYPE_DUMMY = ServiceType.LOCATION;
+
+    public PerformanceManagerService(Context context) {
+        super(context);
+
+        mContext = context;
+
+        // We need a higher priority thread to handle these requests in front of
+        // everything else asynchronously
+        mHandlerThread = new ServiceThread(TAG,
+                Process.THREAD_PRIORITY_DISPLAY, false /*allowIo*/);
+        mHandlerThread.start();
+
+        mHandler = new HintHandler(mHandlerThread.getLooper());
+
+        if (mContext.getResources().getBoolean(R.bool.config_waitForMpctlOnBoot)) {
+            mMpctlReady = false;
+            mWaitMpctlThread = new Thread(() -> {
+                int retries = 20;
+                while (retries-- > 0) {
+                    if (!SystemProperties.getBoolean("sys.post_boot.parsed", false) &&
+                            !SystemProperties.getBoolean("vendor.post_boot.parsed", false)) {
+                        continue;
+                    }
+
+                    if (SystemProperties.get("init.svc.perfd").equals("running") ||
+                            SystemProperties.get("init.svc.vendor.perfd").equals("running") ||
+                            SystemProperties.get("init.svc.perf-hal-1-0").equals("running") ||
+                            SystemProperties.get("init.svc.perf-hal-2-0").equals("running") ||
+                            SystemProperties.get("init.svc.perf-hal-2-1").equals("running") ||
+                            SystemProperties.get("init.svc.perf-hal-2-2").equals("running") ||
+                            SystemProperties.get("init.svc.mpdecision").equals("running")) {
+                        break;
+                    }
+
+                    try {
+                        Thread.sleep(100);
+                    } catch (InterruptedException e) {
+                        Slog.w(TAG, "Interrupted:", e);
+                    }
+                }
+
+                // Give mp-ctl enough time to initialize
+                try {
+                    Thread.sleep(1000);
+                } catch (InterruptedException e) {
+                    Slog.w(TAG, "Interrupted:", e);
+                }
+
+                synchronized (mLock) {
+                    mMpctlReady = true;
+                    applyProfileLocked();
+                }
+            });
+            mWaitMpctlThread.setDaemon(true);
+        } else {
+            mWaitMpctlThread = null;
+        }
+    }
+
+    private class PerformanceSettingsObserver extends ContentObserver {
+
+        private final Uri PERFORMANCE_PROFILE_URI =
+                getUriFor(PERFORMANCE_PROFILE);
+
+        private final ContentResolver mCR;
+
+        public PerformanceSettingsObserver(Context context, Handler handler) {
+            super(handler);
+            mCR = context.getContentResolver();
+        }
+
+        public void observe(boolean enabled) {
+            if (enabled) {
+                mCR.registerContentObserver(PERFORMANCE_PROFILE_URI, false, this);
+                onChange(false);
+            } else {
+                mCR.unregisterContentObserver(this);
+            }
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            int profile = getInt(mCR, PERFORMANCE_PROFILE, PROFILE_BALANCED);
+
+            synchronized (mLock) {
+                if (mUserProfile < 0) {
+                    mUserProfile = profile;
+                    setPowerProfileLocked(mUserProfile, false);
+                }
+            }
+        }
+    };
+
+    @Override
+    public String getFeatureDeclaration() {
+        return LineageContextConstants.Features.PERFORMANCE;
+    }
+
+    @Override
+    public void onStart() {
+        publishBinderService(LineageContextConstants.LINEAGE_PERFORMANCE_SERVICE, mBinder);
+    }
+
+    private void populateProfilesLocked() {
+        mProfiles.clear();
+
+        Resources res = mContext.getResources();
+        String[] profileNames = res.getStringArray(R.array.perf_profile_entries);
+        int[] profileIds = res.getIntArray(R.array.perf_profile_values);
+        String[] profileWeights = res.getStringArray(R.array.perf_profile_weights);
+        String[] profileDescs = res.getStringArray(R.array.perf_profile_summaries);
+
+        for (int i = 0; i < profileIds.length; i++) {
+            if (profileIds[i] >= mNumProfiles) {
+                continue;
+            }
+            float weight = Float.valueOf(profileWeights[i]);
+            mProfiles.put(profileIds[i], new PerformanceProfile(profileIds[i],
+                    weight, profileNames[i], profileDescs[i]));
+        }
+    }
+
+    @Override
+    public void onBootPhase(int phase) {
+        if (phase == PHASE_SYSTEM_SERVICES_READY && !mSystemReady) {
+            synchronized (mLock) {
+                mPm = getLocalService(PowerManagerInternal.class);
+                mNumProfiles = mPm.getFeature(POWER_FEATURE_SUPPORTED_PROFILES);
+
+                if (hasProfiles()) {
+                    populateProfilesLocked();
+
+                    mObserver = new PerformanceSettingsObserver(mContext, mHandler);
+                    mObserver.observe(true);
+                }
+
+                mSystemReady = true;
+
+                if (hasProfiles()) {
+                    setPowerProfileLocked(mUserProfile, false);
+                    mPm.registerLowPowerModeObserver(mLowPowerModeListener);
+                    mContext.registerReceiver(mLocaleChangedReceiver,
+                            new IntentFilter(Intent.ACTION_LOCALE_CHANGED));
+                }
+            }
+        } else if (phase == PHASE_BOOT_COMPLETED && !mMpctlReady) {
+            mWaitMpctlThread.start();
+        }
+    }
+
+    private boolean hasProfiles() {
+        return mNumProfiles > 0;
+    }
+
+    /**
+     * Apply a power profile and persist if fromUser = true
+     * <p>
+     * Must call with lock held.
+     *
+     * @param profile  power profile
+     * @param fromUser true to persist the profile
+     * @return true if the active profile changed
+     */
+    private boolean setPowerProfileLocked(int profile, boolean fromUser) {
+        if (DEBUG) {
+            Slog.v(TAG, String.format(Locale.US,"setPowerProfileL(%d, fromUser=%b)", profile, fromUser));
+        }
+
+        if (!mSystemReady || !mMpctlReady) {
+            Slog.e(TAG, "System is not ready, dropping profile request");
+            return false;
+        }
+
+        if (!mProfiles.containsKey(profile)) {
+            Slog.e(TAG, "Invalid profile: " + profile);
+            return false;
+        }
+
+        boolean isProfileSame = profile == mActiveProfile;
+
+        if (!isProfileSame && profile != PROFILE_POWER_SAVE &&
+                mActiveProfile == PROFILE_POWER_SAVE) {
+            long token = Binder.clearCallingIdentity();
+            mPm.setPowerSaveMode(false);
+            Binder.restoreCallingIdentity(token);
+        }
+
+        /**
+         * It's possible that mCurrrentProfile != getUserProfile() because of a
+         * per-app profile. Store the user's profile preference and then bail
+         * early if there is no work to be done.
+         */
+        if (fromUser) {
+            putInt(mContext.getContentResolver(), PERFORMANCE_PROFILE, profile);
+            mUserProfile = profile;
+        }
+
+        if (isProfileSame) {
+            return false;
+        }
+
+        // Enforce the performance access permission declared by lineage's res package
+        mContext.enforceCallingOrSelfPermission(
+                lineageos.platform.Manifest.permission.PERFORMANCE_ACCESS, null);
+
+        long token = Binder.clearCallingIdentity();
+
+        mActiveProfile = profile;
+
+        mHandler.obtainMessage(MSG_SET_PROFILE, profile,
+                (fromUser ? 1 : 0)).sendToTarget();
+
+        Binder.restoreCallingIdentity(token);
+
+        return true;
+    }
+
+    private void applyProfileLocked() {
+        if (!hasProfiles()) {
+            // don't have profiles, bail.
+            return;
+        }
+
+        final int profile;
+        if (mLowPowerModeEnabled) {
+            // LPM always wins
+            profile = PROFILE_POWER_SAVE;
+        } else {
+            profile = mUserProfile;
+        }
+
+        setPowerProfileLocked(profile, false);
+    }
+
+    private final IBinder mBinder = new IPerformanceManager.Stub() {
+
+        @Override
+        public boolean setPowerProfile(int profile) {
+            synchronized (mLock) {
+                return setPowerProfileLocked(profile, true);
+            }
+        }
+
+        @Override
+        public int getPowerProfile() {
+            synchronized (mLock) {
+                return mUserProfile;
+            }
+        }
+
+        @Override
+        public PerformanceProfile getPowerProfileById(int profile) {
+            synchronized (mLock) {
+                return mProfiles.get(profile);
+            }
+        }
+
+        @Override
+        public PerformanceProfile getActivePowerProfile() {
+            synchronized (mLock) {
+                return mProfiles.get(mUserProfile);
+            }
+        }
+
+        @Override
+        public int getNumberOfProfiles() {
+            return mNumProfiles;
+        }
+
+        @Override
+        public PerformanceProfile[] getPowerProfiles() throws RemoteException {
+            synchronized (mLock) {
+                return mProfiles.values().toArray(new PerformanceProfile[0]);
+            }
+        }
+
+        @Override
+        public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
+
+            synchronized (mLock) {
+                pw.println();
+                pw.println("PerformanceManager Service State:");
+                pw.println();
+
+                if (!hasProfiles()) {
+                    pw.println(" No profiles available.");
+                } else {
+                    pw.println(" User-selected profile: " +
+                            Objects.toString(mProfiles.get(mUserProfile)));
+                    if (mUserProfile != mActiveProfile) {
+                        pw.println(" System-selected profile: " +
+                                Objects.toString(mProfiles.get(mActiveProfile)));
+                    }
+                    pw.println();
+                    pw.println(" Supported profiles:");
+                    for (Map.Entry<Integer, PerformanceProfile> profile : mProfiles.entrySet()) {
+                        pw.println("  " + profile.getKey() + ": " + profile.getValue().toString());
+                    }
+                    pw.println();
+                    mPerformanceLog.dump(pw);
+                }
+            }
+        }
+    };
+
+    private static class PerformanceLog {
+        static final int USER_PROFILE = 2;
+
+        static final String[] EVENTS = new String[] { "USER_PROFILE" };
+
+        private static final int LOG_BUF_SIZE = 25;
+
+        static class Entry {
+            private final long timestamp;
+            private final int event;
+            private final String info;
+
+            Entry(long timestamp_, int event_, String info_) {
+                timestamp = timestamp_;
+                event = event_;
+                info = info_;
+            }
+        }
+
+        private final ArrayDeque<Entry> mBuffer = new ArrayDeque<>(LOG_BUF_SIZE);
+
+        void log(int event, String info) {
+            synchronized (mBuffer) {
+                mBuffer.add(new Entry(System.currentTimeMillis(), event, info));
+                if (mBuffer.size() >= LOG_BUF_SIZE) {
+                    mBuffer.poll();
+                }
+            }
+        }
+
+        void dump(PrintWriter pw) {
+            synchronized (mBuffer) {
+                pw.println("Performance log:");
+                for (Entry entry : mBuffer) {
+                    pw.println(String.format("  %1$tH:%1$tM:%1$tS.%1$tL: %2$14s  %3$s",
+                            new Date(entry.timestamp), EVENTS[entry.event], entry.info));
+                }
+                pw.println();
+            }
+        }
+    }
+
+    /**
+     * Handler for asynchronous operations performed by the performance manager.
+     */
+    private final class HintHandler extends Handler {
+
+        public HintHandler(Looper looper) {
+            super(looper, null, true /*async*/);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_SET_PROFILE:
+                    mPm.setPowerMode(POWER_HINT_SET_PROFILE, msg.arg1 != 1);
+                    mPerformanceLog.log(PerformanceLog.USER_PROFILE, "profile=" + msg.arg1);
+                    break;
+            }
+        }
+    }
+
+    private final PowerManagerInternal.LowPowerModeListener mLowPowerModeListener = new
+            PowerManagerInternal.LowPowerModeListener() {
+
+                @Override
+                public void onLowPowerModeChanged(PowerSaveState state) {
+                    final boolean enabled = state.globalBatterySaverEnabled;
+                    synchronized (mLock) {
+                        if (enabled == mLowPowerModeEnabled) {
+                            return;
+                        }
+                        if (DEBUG) {
+                            Slog.d(TAG, "low power mode enabled: " + enabled);
+                        }
+                        mLowPowerModeEnabled = enabled;
+                        applyProfileLocked();
+                    }
+                }
+
+                @Override
+                public int getServiceType() {
+                    return SERVICE_TYPE_DUMMY;
+                }
+            };
+
+    private final BroadcastReceiver mLocaleChangedReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            synchronized (mLock) {
+                populateProfilesLocked();
+            }
+        }
+    };
+}
diff --git a/lineage/res/AndroidManifest.xml b/lineage/res/AndroidManifest.xml
index 845e8738..d91c51c7 100644
--- a/lineage/res/AndroidManifest.xml
+++ b/lineage/res/AndroidManifest.xml
@@ -63,6 +63,13 @@
                 android:description="@string/permdesc_writeSecureSettings"
                 android:protectionLevel="signature|privileged|development" />
 
+    <!-- Allows low-level access to performance management.
+         <p>Not for use by third-party applications. -->
+    <permission android:name="lineageos.permission.PERFORMANCE_ACCESS"
+                android:label="@string/permlab_perfAccess"
+                android:description="@string/permdesc_perfAccessDesc"
+                android:protectionLevel="signature|privileged" />
+
     <!-- Allows an application to manage LiveDisplay -->
     <permission android:name="lineageos.permission.MANAGE_LIVEDISPLAY"
                 android:label="@string/permlab_manageLiveDisplay"
diff --git a/lineage/res/res/values/arrays.xml b/lineage/res/res/values/arrays.xml
index 69c40eda..f135158a 100644
--- a/lineage/res/res/values/arrays.xml
+++ b/lineage/res/res/values/arrays.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
      Copyright (C) 2015 The CyanogenMod Project
-                   2022 The LineageOS Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -16,6 +15,46 @@
      limitations under the License.
 -->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- Performance profiles -->
+    <string-array name="perf_profile_entries" translatable="false">
+        <item>@string/perf_profile_pwrsv</item>
+        <item>@string/perf_profile_bias_power</item>
+        <item>@string/perf_profile_bal</item>
+        <item>@string/perf_profile_bias_perf</item>
+        <item>@string/perf_profile_perf</item>
+    </string-array>
+
+    <!-- These values are intentionally out of order to give an "ascending"
+         view of the modes while allowing devices to easily omit the bias
+         modes if they are not applicable or needed. These values correspond
+         to the enumeration in PerformanceManager. -->
+    <integer-array name="perf_profile_values" translatable="false">
+        <item>0</item>
+        <item>3</item>
+        <item>1</item>
+        <item>4</item>
+        <item>2</item>
+    </integer-array>
+
+    <!-- Weights for each performance profile, 0 being lowest (powersave) and 1 being
+         highest (performance). Used for sorting -->
+    <string-array name="perf_profile_weights" translatable="false">
+        <item>0.0</item>
+        <item>0.25</item>
+        <item>0.5</item>
+        <item>0.75</item>
+        <item>1.0</item>
+    </string-array>
+
+    <!-- Summary of each profile -->
+    <string-array name="perf_profile_summaries" translatable="false">
+        <item>@string/perf_profile_pwrsv_summary</item>
+        <item>@string/perf_profile_bias_power_summary</item>
+        <item>@string/perf_profile_bal_summary</item>
+        <item>@string/perf_profile_bias_perf_summary</item>
+        <item>@string/perf_profile_perf_summary</item>
+    </string-array>
+
     <!-- LiveDisplay -->
     <string-array name="live_display_entries" translatable="false">
         <item>@string/live_display_auto</item>
diff --git a/lineage/res/res/values/config.xml b/lineage/res/res/values/config.xml
index 380ab5da..c999acad 100644
--- a/lineage/res/res/values/config.xml
+++ b/lineage/res/res/values/config.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
      Copyright (C) 2015 The CyanogenMod Project
-                   2017-2022 The LineageOS Project
+                   2017-2021 The LineageOS Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -103,6 +103,7 @@
     <string-array name="config_externalLineageServices">
         <item>org.lineageos.platform.internal.ProfileManagerService</item>
         <item>org.lineageos.platform.internal.LineageHardwareService</item>
+        <item>org.lineageos.platform.internal.PerformanceManagerService</item>
         <item>org.lineageos.platform.internal.display.LiveDisplayService</item>
         <item>org.lineageos.platform.internal.TrustInterfaceService</item>
         <item>org.lineageos.platform.internal.LineageSettingsService</item>
@@ -265,6 +266,10 @@
     <!-- Whether device has a notch -->
     <bool name="config_haveNotch">false</bool>
 
+    <!-- Whether device needs to wait for Qualcomm MPCTL service to start
+         before setting power profiles on boot. -->
+    <bool name="config_waitForMpctlOnBoot">false</bool>
+
     <!-- Button backlight control. Possible values are:
             0 - Not supported
             1 - Supported, but only on/off mode
diff --git a/lineage/res/res/values/strings.xml b/lineage/res/res/values/strings.xml
index 6b4e067a..ccf4c27f 100644
--- a/lineage/res/res/values/strings.xml
+++ b/lineage/res/res/values/strings.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
      Copyright (C) 2015 The CyanogenMod Project
-                   2017-2022 The LineageOS Project
+               (C) 2017 The LineageOS Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -54,6 +54,20 @@
     <!-- Name of wildcard profile. -->
     <string name="wildcardProfile">Other</string>
 
+    <!-- Performance profiles -->
+    <string name="perf_profile_pwrsv">Power save</string>
+    <string name="perf_profile_bal">Balanced</string>
+    <string name="perf_profile_perf">Performance</string>
+    <string name="perf_profile_bias_power">Efficiency</string>
+    <string name="perf_profile_bias_perf">Quick</string>
+
+    <!-- Performance profiles -->
+    <string name="perf_profile_pwrsv_summary">Maximum power savings, reduces device performance</string>
+    <string name="perf_profile_bal_summary">Balance of optimal performance and power characteristics</string>
+    <string name="perf_profile_perf_summary">High performance mode. Useful for applications requiring low latency and highest throughput when power consumption is not a concern</string>
+    <string name="perf_profile_bias_power_summary">Favor power savings. Limit maximum CPU power and optimize for power saving at the cost of higher latency</string>
+    <string name="perf_profile_bias_perf_summary">Favor performance. Reduces latency with slightly increased power consumption</string>
+
     <!-- LiveDisplay strings -->
     <string name="live_display_title" translatable="false">LiveDisplay</string>
     <string name="live_display_auto">Automatic</string>
@@ -79,6 +93,11 @@
     <string name="accessibility_quick_settings_live_display_changed_night">LiveDisplay changed to night mode.</string>
     <string name="accessibility_quick_settings_live_display_changed_outdoor">LiveDisplay changed to outdoor mode.</string>
 
+    <!-- Performance manager permission title -->
+    <string name="permlab_perfAccess">access performance manager</string>
+    <!-- Performance manager permission description -->
+    <string name="permdesc_perfAccessDesc">Allows an app to access the performance service. Should never be needed for normal apps.</string>
+
     <!-- LiveDisplay manager permission -->
     <string name="permlab_manageLiveDisplay">manage LiveDisplay settings</string>
     <string name="permdesc_manageLiveDisplay">Allows an app to configure advanced display settings.</string>
diff --git a/lineage/res/res/values/symbols.xml b/lineage/res/res/values/symbols.xml
index a7340427..c5589ff3 100644
--- a/lineage/res/res/values/symbols.xml
+++ b/lineage/res/res/values/symbols.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
      Copyright (C) 2015 The CyanogenMod Project
-                   2017-2022 The LineageOS Project
+                   2017-2021 The LineageOS Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -22,6 +22,24 @@
     <java-symbol type="xml" name="profile_default" />
     <java-symbol type="string" name="wildcardProfile" />
 
+    <!-- Performance Profiles -->
+    <java-symbol type="array" name="perf_profile_entries" />
+    <java-symbol type="array" name="perf_profile_values" />
+    <java-symbol type="array" name="perf_profile_weights" />
+    <java-symbol type="array" name="perf_profile_summaries" />
+    <java-symbol type="string" name="perf_profile_pwrsv" />
+    <java-symbol type="string" name="perf_profile_bal" />
+    <java-symbol type="string" name="perf_profile_perf" />
+    <java-symbol type="string" name="perf_profile_bias_power" />
+    <java-symbol type="string" name="perf_profile_bias_perf" />
+    <java-symbol type="string" name="perf_profile_pwrsv_summary" />
+    <java-symbol type="string" name="perf_profile_bal_summary" />
+    <java-symbol type="string" name="perf_profile_perf_summary" />
+    <java-symbol type="string" name="perf_profile_bias_power_summary" />
+    <java-symbol type="string" name="perf_profile_bias_perf_summary" />
+
+    <java-symbol type="bool" name="config_waitForMpctlOnBoot" />
+
     <!-- Proximity check on screen on -->
     <java-symbol type="bool" name="config_proximityCheckOnWake" />
 
diff --git a/sdk/src/java/lineageos/power/IPerformanceManager.aidl b/sdk/src/java/lineageos/power/IPerformanceManager.aidl
new file mode 100644
index 00000000..14803db3
--- /dev/null
+++ b/sdk/src/java/lineageos/power/IPerformanceManager.aidl
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2015, The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+
+package lineageos.power;
+
+import lineageos.power.PerformanceProfile;
+
+/** @hide */
+interface IPerformanceManager {
+
+    boolean setPowerProfile(int profile);
+
+    int getPowerProfile();
+
+    int getNumberOfProfiles();
+
+    PerformanceProfile[] getPowerProfiles();
+
+    PerformanceProfile getPowerProfileById(int profile);
+
+    PerformanceProfile getActivePowerProfile();
+}
diff --git a/sdk/src/java/lineageos/power/PerformanceManager.java b/sdk/src/java/lineageos/power/PerformanceManager.java
new file mode 100644
index 00000000..088175ba
--- /dev/null
+++ b/sdk/src/java/lineageos/power/PerformanceManager.java
@@ -0,0 +1,267 @@
+/*
+ * Copyright (C) 2015 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package lineageos.power;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.SortedSet;
+import java.util.TreeSet;
+
+import lineageos.app.LineageContextConstants;
+
+/**
+ *
+ */
+public class PerformanceManager {
+
+    public static final String TAG = "PerformanceManager";
+
+    /**
+     * Power save profile
+     *
+     * This mode sacrifices performance for maximum power saving.
+     */
+    public static final int PROFILE_POWER_SAVE = 0;
+
+    /**
+     * Balanced power profile
+     * 
+     * The default mode for balanced power savings and performance
+     */
+    public static final int PROFILE_BALANCED = 1;
+
+    /**
+     * High-performance profile
+     * 
+     * This mode sacrifices power for maximum performance
+     */
+    public static final int PROFILE_HIGH_PERFORMANCE = 2;
+
+    /**
+     * Power save bias profile
+     * 
+     * This mode decreases performance slightly to improve
+     * power savings. 
+     */
+    public static final int PROFILE_BIAS_POWER_SAVE = 3;
+    
+    /**
+     * Performance bias profile
+     * 
+     * This mode improves performance at the cost of some power.
+     */
+    public static final int PROFILE_BIAS_PERFORMANCE = 4;
+
+    /**
+     * @hide
+     */
+    public static final int[] POSSIBLE_POWER_PROFILES = new int[] {
+            PROFILE_POWER_SAVE,
+            PROFILE_BALANCED,
+            PROFILE_HIGH_PERFORMANCE,
+            PROFILE_BIAS_POWER_SAVE,
+            PROFILE_BIAS_PERFORMANCE
+    };
+
+    private int mNumberOfProfiles = 0;
+
+    /**
+     * Broadcast sent when profile is changed
+     */
+    public static final String POWER_PROFILE_CHANGED = "lineageos.power.PROFILE_CHANGED";
+
+    private static IPerformanceManager sService;
+    private static PerformanceManager sInstance;
+
+    private PerformanceManager(Context context) {
+        sService = getService();
+        if (context.getPackageManager().hasSystemFeature(
+                LineageContextConstants.Features.PERFORMANCE) && sService == null) {
+            Log.wtf(TAG, "Unable to get PerformanceManagerService. The service" +
+                    " either crashed, was not started, or the interface has been called to early" +
+                    " in SystemServer init");
+        }
+        try {
+            if (sService != null) {
+                mNumberOfProfiles = sService.getNumberOfProfiles();
+            }
+        } catch (RemoteException e) {
+        }
+    }
+
+    public static PerformanceManager getInstance(Context context) {
+        if (sInstance == null) {
+            sInstance = new PerformanceManager(context);
+        }
+        return sInstance;
+    }
+
+    /** @hide */
+    public static IPerformanceManager getService() {
+        if (sService != null) {
+            return sService;
+        }
+        IBinder b = ServiceManager.getService(LineageContextConstants.LINEAGE_PERFORMANCE_SERVICE);
+        if (b != null) {
+            sService = IPerformanceManager.Stub.asInterface(b);
+            return sService;
+        }
+        return null;
+    }
+
+    private boolean checkService() {
+        if (sService == null) {
+            Log.w(TAG, "not connected to PerformanceManagerService");
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Returns the number of supported profiles, -1 if unsupported
+     * This is queried via the PowerHAL.
+     */
+    public int getNumberOfProfiles() {
+        return mNumberOfProfiles;
+    }
+
+    /**
+     * Set the system power profile
+     *
+     * @throws IllegalArgumentException if invalid
+     */
+    public boolean setPowerProfile(int profile) {
+        if (mNumberOfProfiles < 1) {
+            throw new IllegalArgumentException("Power profiles not enabled on this system!");
+        }
+
+        boolean changed = false;
+        try {
+            if (checkService()) {
+                changed = sService.setPowerProfile(profile);
+            }
+        } catch (RemoteException e) {
+            throw new IllegalArgumentException(e);
+        }
+        return changed;
+    }
+
+    /**
+     * Set the system power profile
+     *
+     * @throws IllegalArgumentException if invalid
+     */
+    public boolean setPowerProfile(PerformanceProfile profile) {
+        if (mNumberOfProfiles < 1) {
+            throw new IllegalArgumentException("Power profiles not enabled on this system!");
+        }
+
+        boolean changed = false;
+        try {
+            if (checkService()) {
+                changed = sService.setPowerProfile(profile.getId());
+            }
+        } catch (RemoteException e) {
+            throw new IllegalArgumentException(e);
+        }
+        return changed;
+    }
+
+    /**
+     * Gets the current power profile
+     *
+     * Returns -1 if power profiles are not enabled
+     */
+    public int getPowerProfile() {
+        int ret = -1;
+        if (mNumberOfProfiles > 0) {
+            try {
+                if (checkService()) {
+                    ret = sService.getPowerProfile();
+                }
+            } catch (RemoteException e) {
+                // nothing
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * Gets the specified power profile
+     *
+     * Returns null if power profiles are not enabled or the profile was not found
+     */
+    public PerformanceProfile getPowerProfile(int profile) {
+        PerformanceProfile ret = null;
+        if (mNumberOfProfiles > 0) {
+            try {
+                if (checkService()) {
+                    ret = sService.getPowerProfileById(profile);
+                }
+            } catch (RemoteException e) {
+                // nothing
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * Gets the currently active performance profile
+     *
+     * Returns null if no profiles are available.
+     */
+    public PerformanceProfile getActivePowerProfile() {
+        PerformanceProfile ret = null;
+        if (mNumberOfProfiles > 0) {
+            try {
+                if (checkService()) {
+                    ret = sService.getActivePowerProfile();
+                }
+            } catch (RemoteException e) {
+                // nothing
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * Gets a set, sorted by weight, of all supported power profiles
+     *
+     * Returns an empty set if power profiles are not enabled
+     */
+    public SortedSet<PerformanceProfile> getPowerProfiles() {
+        final SortedSet<PerformanceProfile> profiles = new TreeSet<PerformanceProfile>();
+        if (mNumberOfProfiles > 0) {
+            try {
+                if (checkService()) {
+                    PerformanceProfile[] p = sService.getPowerProfiles();
+                    if (p != null) {
+                        profiles.addAll(Arrays.asList(p));
+                    }
+                }
+            } catch (RemoteException e) {
+                // nothing
+            }
+        }
+        return Collections.unmodifiableSortedSet(profiles);
+    }
+}
diff --git a/sdk/src/java/lineageos/power/PerformanceProfile.aidl b/sdk/src/java/lineageos/power/PerformanceProfile.aidl
new file mode 100644
index 00000000..36d7ca55
--- /dev/null
+++ b/sdk/src/java/lineageos/power/PerformanceProfile.aidl
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package lineageos.power;
+
+parcelable PerformanceProfile;
diff --git a/sdk/src/java/lineageos/power/PerformanceProfile.java b/sdk/src/java/lineageos/power/PerformanceProfile.java
new file mode 100644
index 00000000..5a8ea8f2
--- /dev/null
+++ b/sdk/src/java/lineageos/power/PerformanceProfile.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package lineageos.power;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.util.Objects;
+
+import lineageos.os.Build;
+import lineageos.os.Concierge;
+
+/**
+ * Encapsulates information about an available system power/peformance profile, managed
+ * by the PerformanceManager.
+ */
+public class PerformanceProfile implements Parcelable, Comparable<PerformanceProfile> {
+
+    private final int mId;
+
+    private final float mWeight;
+
+    private final String mName;
+
+    private final String mDescription;
+
+    public PerformanceProfile(int id, float weight, String name, String description) {
+        mId = id;
+        mWeight = weight;
+        mName = name;
+        mDescription = description;
+    }
+
+    private PerformanceProfile(Parcel in) {
+        Concierge.ParcelInfo parcelInfo = Concierge.receiveParcel(in);
+        int parcelableVersion = parcelInfo.getParcelVersion();
+
+        mId = in.readInt();
+        mWeight = in.readFloat();
+        mName = in.readString();
+        mDescription = in.readString();
+
+        if (parcelableVersion >= Build.LINEAGE_VERSION_CODES.GUAVA) {
+            // nothing yet
+        }
+
+        parcelInfo.complete();
+    }
+
+    /**
+     * Unique identifier for this profile. Must match values used by the PowerHAL.
+     *
+     * @return the id
+     */
+    public int getId() {
+        return mId;
+    }
+
+    /**
+     * The profile's weight, from 0 to 1, with 0 being lowest (power save), 1 being
+     * highest (performance), and 0.5 as the balanced default profile. Other
+     * values may be seen, depending on the device. This value can be used for
+     * sorting.
+     *
+     * @return weight
+     */
+    public float getWeight() {
+        return mWeight;
+    }
+
+    /**
+     * A localized name for the profile, suitable for display.
+     *
+     * @return name
+     */
+    public String getName() {
+        return mName;
+    }
+
+    /**
+     * A localized description of the profile, suitable for display.
+     *
+     * @return description
+     */
+    public String getDescription() {
+        return mDescription;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        Concierge.ParcelInfo parcelInfo = Concierge.prepareParcel(dest);
+
+        dest.writeInt(mId);
+        dest.writeFloat(mWeight);
+        dest.writeString(mName);
+        dest.writeString(mDescription);
+
+        parcelInfo.complete();
+    }
+
+    public static final Creator<PerformanceProfile> CREATOR = new Creator<PerformanceProfile>() {
+        @Override
+        public PerformanceProfile createFromParcel(Parcel in) {
+            return new PerformanceProfile(in);
+        }
+
+        @Override
+        public PerformanceProfile[] newArray(int size) {
+            return new PerformanceProfile[size];
+        }
+    };
+
+    @Override
+    public int compareTo(PerformanceProfile other) {
+        return Float.compare(mWeight, other.mWeight);
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == null) {
+            return false;
+        }
+        if (!getClass().equals(other.getClass())) {
+            return false;
+        }
+
+        PerformanceProfile o = (PerformanceProfile) other;
+        return Objects.equals(mId, o.mId);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mId);
+    }
+
+    @Override
+    public String toString() {
+        return String.format("PerformanceProfile[id=%d, weight=%f, name=%s desc=%s]",
+                mId, mWeight, mName, mDescription);
+    }
+}
diff --git a/sdk/src/java/lineageos/providers/LineageSettings.java b/sdk/src/java/lineageos/providers/LineageSettings.java
index b3123e69..8bd58980 100644
--- a/sdk/src/java/lineageos/providers/LineageSettings.java
+++ b/sdk/src/java/lineageos/providers/LineageSettings.java
@@ -2783,6 +2783,18 @@ public final class LineageSettings {
         public static final int RING_HOME_BUTTON_BEHAVIOR_DEFAULT =
                 RING_HOME_BUTTON_BEHAVIOR_DO_NOTHING;
 
+        /**
+         * Performance profile
+         * @hide
+         */
+        public static final String PERFORMANCE_PROFILE = "performance_profile";
+
+        /**
+         * App-based performance profile selection
+         * @hide
+         */
+        public static final String APP_PERFORMANCE_PROFILES_ENABLED = "app_perf_profiles_enabled";
+
         /**
          * Launch actions for left/right lockscreen targets
          * @hide
@@ -3001,6 +3013,8 @@ public final class LineageSettings {
                 LineageSettings.Secure.LOCKSCREEN_TARGETS,
                 LineageSettings.Secure.RING_HOME_BUTTON_BEHAVIOR,
                 LineageSettings.Secure.DEVELOPMENT_SHORTCUT,
+                LineageSettings.Secure.PERFORMANCE_PROFILE,
+                LineageSettings.Secure.APP_PERFORMANCE_PROFILES_ENABLED,
                 LineageSettings.Secure.QS_LOCATION_ADVANCED,
                 LineageSettings.Secure.LOCKSCREEN_VISUALIZER_ENABLED,
                 LineageSettings.Secure.LOCK_PASS_TO_SECURITY_VIEW
diff --git a/tests/src/org/lineageos/tests/power/unit/PerfomanceManagerTest.java b/tests/src/org/lineageos/tests/power/unit/PerfomanceManagerTest.java
new file mode 100644
index 00000000..4259ef62
--- /dev/null
+++ b/tests/src/org/lineageos/tests/power/unit/PerfomanceManagerTest.java
@@ -0,0 +1,111 @@
+/**
+ * Copyright (c) 2016, The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.lineageos.tests.power.unit;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import lineageos.app.LineageContextConstants;
+import lineageos.power.IPerformanceManager;
+import lineageos.power.PerformanceManager;
+import lineageos.power.PerformanceProfile;
+
+/**
+ * Code coverage for public facing {@link PerformanceManager} interfaces.
+ * The test below will save and restore the current performance profile to
+ * not impact successive tests.
+ */
+public class PerfomanceManagerTest extends AndroidTestCase {
+    private static final String TAG = PerfomanceManagerTest.class.getSimpleName();
+    private static final int IMPOSSIBLE_POWER_PROFILE = -1;
+    private PerformanceManager mLineagePerformanceManager;
+    private PerformanceProfile mSavedPerfProfile;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        // Only run this if we support performance abstraction
+        org.junit.Assume.assumeTrue(mContext.getPackageManager().hasSystemFeature(
+                LineageContextConstants.Features.PERFORMANCE));
+        mLineagePerformanceManager = PerformanceManager.getInstance(mContext);
+        // Save the perf profile for later restore.
+        mSavedPerfProfile = mLineagePerformanceManager.getPowerProfile(
+                mLineagePerformanceManager.getPowerProfile());
+    }
+
+    @SmallTest
+    public void testManagerExists() {
+        assertNotNull(mLineagePerformanceManager);
+    }
+
+    @SmallTest
+    public void testManagerServiceIsAvailable() {
+        IPerformanceManager ilineageStatusBarManager = mLineagePerformanceManager.getService();
+        assertNotNull(ilineageStatusBarManager);
+    }
+
+    @SmallTest
+    public void testPowerProfileCantBeSetIfNoneSupported() {
+        // Assert that if we attempt to set a power profile if none supported
+        // then we receive a failed response from the service.
+        if (mLineagePerformanceManager.getNumberOfProfiles() == 0) {
+            for (int powerProfile = 0; powerProfile <
+                    PerformanceManager.POSSIBLE_POWER_PROFILES.length; powerProfile++) {
+                assertFalse(mLineagePerformanceManager.setPowerProfile(powerProfile));
+            }
+        }
+    }
+
+    @SmallTest
+    public void testGetPowerProfile() {
+        assertNotSame(IMPOSSIBLE_POWER_PROFILE, mSavedPerfProfile);
+    }
+
+    @SmallTest
+    public void testSetAndGetPowerProfile() {
+        // Identify what power profiles are supported. The api currently returns
+        // the total number of profiles supported in an ordered manner, thus we can
+        // assume what they are and if we can set everything correctly.
+        // TODO: Don't skip powersave. Skipped due to powersave being ignored while device plugged
+        for (int powerProfile = 1; powerProfile <
+                PerformanceManager.POSSIBLE_POWER_PROFILES.length; powerProfile++) {
+            if (powerProfile < mLineagePerformanceManager.getNumberOfProfiles()) {
+                //It is supported, set it and test if it was set
+                if (mLineagePerformanceManager.getPowerProfile() != powerProfile) {
+                    mLineagePerformanceManager.setPowerProfile(powerProfile);
+                    // Verify that it was set correctly.
+                    assertEquals(powerProfile, mLineagePerformanceManager.getPowerProfile());
+                }
+            } else {
+                assertFalse(mLineagePerformanceManager.setPowerProfile(powerProfile));
+            }
+        }
+    }
+
+    @SmallTest
+    public void testGetPerfProfileHasAppProfiles() {
+        // No application has power save by default
+        assertEquals(false, mLineagePerformanceManager.getProfileHasAppProfiles(
+                PerformanceManager.PROFILE_POWER_SAVE));
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        // Reset
+        mLineagePerformanceManager.setPowerProfile(mSavedPerfProfile.getId());
+    }
+}
diff --git a/tests/src/org/lineageos/tests/versioning/unit/apiv4/ApiV4PriorReleaseInterfaces.java b/tests/src/org/lineageos/tests/versioning/unit/apiv4/ApiV4PriorReleaseInterfaces.java
index 4380f656..3e29d58b 100644
--- a/tests/src/org/lineageos/tests/versioning/unit/apiv4/ApiV4PriorReleaseInterfaces.java
+++ b/tests/src/org/lineageos/tests/versioning/unit/apiv4/ApiV4PriorReleaseInterfaces.java
@@ -58,6 +58,17 @@ public class ApiV4PriorReleaseInterfaces {
         // DRAGONFRUIT BEGIN
     }
 
+    //PerformanceManager Aidl (IPerformanceManager)
+    static {
+        Map<String, Integer> perfMap = getInternalInterfaceMap("IPerformanceManager");
+        // DRAGONFRUIT BEGIN
+        perfMap.put("cpuBoost", 1);
+        perfMap.put("setPowerProfile", 2);
+        perfMap.put("getPowerProfile", 3);
+        perfMap.put("getNumberOfProfiles", 4);
+        perfMap.put("getProfileHasAppProfiles", 5);
+    }
+
     //ExternalViewProviderFactory Aidl (IExternalViewProviderFactory)
     static {
         Map<String, Integer> extProviderMap =
-- 
2.25.1

